---
sidebar_position: 22
draft: false
title: 21. API-字体
description: GPIO Zero的字体API文档，用于LED字符显示的字体加载和解析功能。
keywords: [树莓派, GPIO, Python, Raspberry Pi, gpiozero, 字体, LED显示, 七段显示, 十四段显示]
last_update:
  date: 2026-02-01
---
import Normal from "./_normal.mdx";
import {SourceClass} from "/js/gpiozeroutils.js";

# API-字体

GPIO Zero 包含一个"字体"概念，这与您可能熟悉的有所不同。虽然典型的打印字体确定如何在页面上呈现特定字符，但 GPIO Zero 字体确定如何通过一系列灯光（如 LED 段）呈现特定字符（例如，使用 `LEDCharDisplay` 或 `LEDMultiCharDisplay`）。

因此，GPIO Zero 的字体是相当简单的事务，只是字符到 LED 状态元组的映射。尽管如此，拥有一个"友好"的格式来创建此类字体还是很有帮助的，在此模块中，库为此目的提供了几个例程。

模块本身通常按如下方式导入：

```python
from gpiozero import fonts
```

## 字体解析

<SourceClass funname="gpiozero.fonts.load_font_7seg" funargs="filename_or_obj" />

给定一个文件名或类文件对象，将其解析为 [7 段显示器](https://en.wikipedia.org/wiki/Seven-segment_display) 的字体定义，返回适用于 `LEDCharDisplay` 的 `dict`。

文件格式是一种简单的基于文本的格式，其中空白行和以 # 开头的行被忽略。所有其他行都被假定为字符定义组，它们是按以下方式布局的 3x3 字符单元：

```text
Ca
fgb
edc
```

其中 C 是被定义的字符，a-g 定义该位置 LED 的状态。如果 a、d 和 g 是"_"，则它们为开启状态。如果 b、c、e 和 f 是"|"，则它们为开启状态。这些位置的任何其他字符都被视为关闭。例如，您可以定义以下字符：

```text
 .  0_  1.  2_  3_  4.  5_  6_  7_  8_  9_
... |.| ..| ._| ._| |_| |_. |_. ..| |_| |_|
... |_| ..| |_. ._| ..| ._| |_| ..| |_| ._|
```

在上面的示例中，空位置用"."标记，但大部分可以留空。但是，第一项定义了空格（" "）字符，需要在其定义中包含*一些*非空格字符，因为解析器还会去除空列（通常出现在字符定义之间）。这也是"1"的定义必须包含一些东西来填充中间列的原因。

<SourceClass funname="gpiozero.fonts.load_font_14seg" funargs="filename_or_obj" />

给定一个文件名或类文件对象，将其解析为 [14 段显示器](https://en.wikipedia.org/wiki/Fourteen-segment_display) 的字体定义，返回适用于 `LEDCharDisplay` 的 `dict`。

文件格式是一种简单的基于文本的格式，其中空白行和以 # 开头的行被忽略。所有其他行都被假定为字符定义组，它们是按以下方式布局的 5x5 字符单元：

```text
X.a..
fijkb
.g.h.
elmnc
..d..
```

其中 X 是被定义的字符，a-n 定义该位置 LED 的状态。如果 a、d、g 和 h 是"-"，则它们为开启状态。如果 b、c、e、f、j 和 m 是"|"，则它们为开启状态。如果 i 和 n 是"\"，则它们为开启状态。最后，如果 k 和 l 是"/"，则它们为开启状态。这些位置的任何其他字符都被视为关闭。例如，您可以定义以下字符：

```text
 .... 0---  1..   2---  3---  4     5---  6---  7---. 8---  9---
..... |  /|    /|     |     | |   | |     |        /  |   | |   |
..... | / |     |  ---    --   ---|  ---  |---    |    ---   ---|
..... |/  |     | |         |     |     | |   |   |   |   |     |
.....  ---         ---   ---         ---   ---         ---
```

在上面的示例中，几个位置有多余的字符。例如，"0"定义中心的"/"，或"8"中间的"-"。这些位置被忽略，但仍然被填充以使形状更明显。

这些多余的位置同样可以留空。但是，第一项定义了空格（" "）字符，需要在其定义中包含*一些*非空格字符，因为解析器还会去除空列（通常出现在字符定义之间），并验证定义是 5 列宽和 5 行高。

这也解释了为什么在"1"字符的定义顶部插入了占位符字符（"."）。否则解析器将去除这些空列并判定定义无效（因为结果只有 3 列宽）。

<SourceClass funname="gpiozero.fonts.load_segment_font" funargs="filename_or_obj, width, height, pins" />

用于解析段字体定义文件的通用函数。

如果您正在使用"标准"的 [7 段](https://en.wikipedia.org/wiki/Seven-segment_display) 或 [14 段](https://en.wikipedia.org/wiki/Fourteen-segment_display) 显示器，您*不需要*这个函数；请参阅 `load_font_7seg()` 或 `load_font_14seg()`。但是，如果您正在使用另一种样式的分段显示器并希望为自定义格式构建解析器，这就是您需要的函数。

*filename_or_obj* 参数只是要加载的类文件对象或文件名。这通常从调用函数传入。

*width* 和 *height* 参数给出每个字符定义的宽度和高度（以字符为单位）。例如，对于 7 段显示器，这些是 3 和 3。最后，*pins* 是一个元组列表，定义字符数组中每个引脚定义的位置，以及标记该位置"活动"的字符。

例如，对于 7 段显示器，此函数按如下方式调用：

```python
load_segment_font(filename_or_obj, width=3, height=3, pins=[
    (1, '_'), (5, '|'), (8, '|'), (7, '_'),
    (6, '|'), (3, '|'), (4, '_')])
```

这规定每个字符将由一个 3x3 字符网格定义，该网格将转换为一个九字符字符串，如下所示：

```text
012
345  ==>  '012345678'
678
```

位置 0 始终假定为被定义的字符。然后 *pins* 列表指定：第一个引脚是位置 1 的字符，当该字符为"_"时为"开启"。第二个引脚是位置 5 的字符，当该字符为"|"时为"开启"，依此类推。

<Normal />
